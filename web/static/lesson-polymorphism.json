{"code":"// Person.java\npublic class Person {\n    public void sleep() {\n        System.out.println(\"ZZzZzzzzz\");\n    }\n}\n// Student.java\npublic class Student extends Person {\n    public void study() {\n        System.out.println(\"*pages turning*\")\n    } \n}\n\nPerson p = new Student();\nStudent s = new Person();\n\nStudent me = new Student();\ns.sleep(); //At runtime, outputs: ZZzZzzzzz\ns.study(); //At runtime, outputs: *pages turning*\n\nPerson s = new Student();\ns.study(); // What does this output??","expl":["### Compile time inheritance in Java\n\nHow does Java check to see if your inheritance code \nis correct?","Let's look at some code snippets:\n\nWe have a `Person` class and a `Student` class. The \nrelationship between `Person` and `Student` can be described\nin English as:\n\"a `Student` is-a `Person`\".","First, a simple declaration. We've seen this plenty of times\nbefore, except that now the type on the left isn't the same\nas the type on the right!\n\nWill this statement compile?","This compiles just fine because our class header is\n`public class Student extends Person`. In English, this \nwould translate to \"every `Student` is a `Person`\".\n\nWhat about the opposite statement?","This, of course, does not compile because not all\npeople are students. In other words, it cannot be said that every `Person` is\na `Student`.\n\nWhat the compiler is doing here is checking to see if \n`Student` is **above** `Person` in the inheritance chain.\nBecause `Student` extends `Person` and not the other way around,\nJava refuses to compile.","Now let's give `Person` something to do.\n\nAll people need sleep, so let's define a `sleep()` method.\nHow does this method affect a `Student` object?","This code compiles fine, and runs great!\nThis result isn't too surprising when you look at it\nlogically: all students are people, \nand people can sleep. Therefore, all students can sleep.\n\nBut what if we do the opposite? Let's forget about \nthe sleep method for now, and instead define a `study()`\nmethod in `Student`.","No surprises here.","Let's change things up a little. What if we make the \ncompile-time type of our `Student` object a `Person` instead?\n\nIn other words, we're changing our variable declaration from\n`Student s` to `Person s`, while keeping everything else\nthe same.","Let's think like the compiler for a \nsecond, and step through this code line by line.","First, the compiler checks to see whether the compile time\ntype we're giving in our declaration is valid for the object.","This first line works just fine, as we saw earlier.","Now let's look at the next line.\n\nRemember that `s` was declared as a `Person`. The compiler\ndoesn't know or care that `s` was set equal to a\n`new Student()`.\nAll it sees is the `Person` type we wrote when\ndeclaring `s`.","As you can see, this line doesn't compile.\n\nThe compiler sees `s` as a `Person`, and `Person` doesn't\nhave a `study()` method! Even though `s` is _really_ a\n`Student` (if we could run the program), the way we've\ndeclared it causes it to be \"generalized\" as just a plain\nold person.\n\nIn summary, this statement would be perfectly valid at \nruntime but fails during compile-time. ","You have to remember that the type system of Java is mainly to help\nyou as the programmer write and debug code. Java\nhas a distinct compilation step before your code can run, and\nit can't possibly check for every possible exception that could occur.\n\nInstead, when checking for issues, the compiler focuses\non the types that you give to your variables.\n\nThis is why the code we're looking at doesn't compile, while\nsomething like:\n```\nStudent badStudent = null;\nnullStudent.study();\n```\n\nwould compile just fine.\n\n*(remember that this would throw a `NullPointerException`,\nat runtime)*","You have to remember that the type system of Java is mainly to help\nyou as the programmer write and debug code. Java\nhas a distinct compilation step before your code can run, and\nit can't possibly check for every possible exception that could occur.\n\nInstead, when checking for issues, the compiler focuses\non the types that you give to your variables.\n\nThis is why the code we're looking at doesn't compile, while\nsomething like:\n```\nStudent badStudent = null;\nnullStudent.study();\n```\n\nwould compile just fine.\n\n*(remember that this would throw a `NullPointerException`,\nat runtime)*"],"regions":[],"meta":{"code_filename":"Person.java"}}
